log_lik <- list_of_log_liks[[k]]
log_lik <- list_of_log_liks[[1]]
log_lik_heldout[heldout==1] <- log_lik[heldout==1]
log_lik_heldout
ee <- extract_log_lik_K(ss,holdout_10)
log_lik_heldout[heldout==1]
log_lik_heldout[heldout==1] <- 100000
log_lik_heldout
extract_log_lik_K <- function(list_of_stanfits, list_of_holdout, ...){
K <- length(list_of_stanfits)
list_of_log_liks <- plyr::llply(1:K, function(k){
extract_log_lik(list_of_stanfits[[k]],...)
})
# `log_lik_heldout` will include the loglike of all the held out data of all the folds.
# We define `log_lik_heldout` as a (samples x N_obs) matrix
# (similar to each log_lik matrix)
log_lik_heldout <- list_of_log_liks[[1]] * NA
for(k in 1:K){
log_lik <- list_of_log_liks[[k]]
samples <- dim(log_lik)[1]
N_obs <- dim(log_lik)[2]
# This is a matrix with the same size as log_lik_heldout
# with 1 if the data was held out in the fold k
heldout <- matrix(rep(list_of_holdout[[k]], each = samples), nrow = samples)
# Sanity check that the previous log_lik is not being overwritten:
if(any(!is.na(log_lik_heldout[heldout==1]))){
warning("Heldout log_lik has been overwritten!!!!")
}
# We save here the log_lik of the fold k in the matrix:
log_lik_heldout[heldout==1] <- log_lik[heldout==1]
}
return(log_lik_heldout)
}
extract_log_lik_K(ss,holdout_10)
extract_log_lik_K <- function(list_of_stanfits, list_of_holdout, ...){
K <- length(list_of_stanfits)
list_of_log_liks <- plyr::llply(1:K, function(k){
extract_log_lik(list_of_stanfits[[k]],...)
})
# `log_lik_heldout` will include the loglike of all the held out data of all the folds.
# We define `log_lik_heldout` as a (samples x N_obs) matrix
# (similar to each log_lik matrix)
log_lik_heldout <- list_of_log_liks[[1]] * NA
for(k in 1:K){
log_lik <- list_of_log_liks[[k]]
samples <- dim(log_lik)[1]
N_obs <- dim(log_lik)[2]
# This is a matrix with the same size as log_lik_heldout
# with 1 if the data was held out in the fold k
heldout <- matrix(rep(list_of_holdout[[k]], each = samples), nrow = samples)
# Sanity check that the previous log_lik is not being overwritten:
if(any(!is.na(log_lik_heldout[heldout==1]))){
warning("Heldout log_lik has been overwritten!!!!")
}
# We save here the log_lik of the fold k in the matrix:
log_lik_heldout[heldout==1] <- as.numeric(log_lik[heldout==1])
}
return(log_lik_heldout)
}
ee <- extract_log_lik_K(ss,holdout_10)
lapply(holdout_10,function(x) which(x==1))
table(unlist(lapply(holdout_10,function(x) which(x==1))))
is.matrix(ee)
is.matrix(log_lik)
extract_log_lik_K <- function(list_of_stanfits, list_of_holdout, ...){
K <- length(list_of_stanfits)
list_of_log_liks <- plyr::llply(1:K, function(k){
extract_log_lik(list_of_stanfits[[k]],...)
})
# `log_lik_heldout` will include the loglike of all the held out data of all the folds.
# We define `log_lik_heldout` as a (samples x N_obs) matrix
# (similar to each log_lik matrix)
log_lik_heldout <- list_of_log_liks[[1]] * NA
for(k in 1:K){
log_lik <- list_of_log_liks[[k]]
samples <- dim(log_lik)[1]
N_obs <- dim(log_lik)[2]
# This is a matrix with the same size as log_lik_heldout
# with 1 if the data was held out in the fold k
heldout <- matrix(rep(list_of_holdout[[k]], each = samples), nrow = samples)
# Sanity check that the previous log_lik is not being overwritten:
if(any(!is.na(log_lik_heldout[heldout==1]))){
warning("Heldout log_lik has been overwritten!!!!")
}
# We save here the log_lik of the fold k in the matrix:
log_lik_heldout[heldout==1] <- as.numeric(log_lik[heldout==1])
if(!is.matrix(log_lik_heldout)){
print(k)
}
}
return(log_lik_heldout)
}
ee <- extract_log_lik_K(ss,holdout_10)
ee
sum(ee,na.rm=TRUE)
sum(ee,na.rm=TRUE)/10
log(sum(ee,na.rm=TRUE)/10)/100
N <- 100
K <- 2
foo <- function(N){
hh <- sample(1:N,size = ceiling(N/n_fold),replace = FALSE)
tmp <- rep(0,N)
tmp[hh] <- 1
return(tmp)}
holdout_10 <- lapply(1:10,function(x) foo(N))
n_fold <- 10
foo <- function(N){
hh <- sample(1:N,size = ceiling(N/n_fold),replace = FALSE)
tmp <- rep(0,N)
tmp[hh] <- 1
return(tmp)}
holdout_10 <- lapply(1:10,function(x) foo(N))
X <- cbind(rep(1,N),runif(N,-2,2))
X <- cbind(rep(1,N),runif(N,-2,2))
y <- matrix(runif(N))
X
y
X <- cbind(rep(1,N),runif(N,-2,2))
y <- matrix(runif(N),-2,2)
y <- matrix(runif(N,-2,2))
data_m <- list(N=N,K=K,X=X,y=y)
data_l <- rep(list(data_m),10)
for(i in 1:10) data_l[[i]]$holdout <- holdout_10[[i]]
N <- 100
K <- 2
n_fold <- 10
foo <- function(N){
hh <- sample(1:N,size = ceiling(N/n_fold),replace = FALSE)
tmp <- rep(0,N)
tmp[hh] <- 1
return(tmp)}
holdout_10 <- lapply(1:10,function(x) foo(N))
X <- cbind(rep(1,N),runif(N,-2,2))
y <- matrix(runif(N,-2,2))
data_m <- list(N=N,K=K,X=X,y=y)
data_l <- rep(list(data_m),10)
for(i in 1:10) data_l[[i]]$holdout <- holdout_10[[i]]
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=1,cores=2,iter=10)
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=2,cores=2,iter=10)
data_l
ss
ee <- extract_log_lik_K(ss,holdout_10)
extract_log_lik_K <- function(list_of_stanfits, list_of_holdout, ...){
K <- length(list_of_stanfits)
list_of_log_liks <- plyr::llply(1:K, function(k){
extract_log_lik(list_of_stanfits[[k]],...)
})
# `log_lik_heldout` will include the loglike of all the held out data of all the folds.
# We define `log_lik_heldout` as a (samples x N_obs) matrix
# (similar to each log_lik matrix)
log_lik_heldout <- list_of_log_liks[[1]] * NA
for(k in 1:K){
log_lik <- list_of_log_liks[[k]]
samples <- dim(log_lik)[1]
N_obs <- dim(log_lik)[2]
# This is a matrix with the same size as log_lik_heldout
# with 1 if the data was held out in the fold k
heldout <- matrix(rep(list_of_holdout[[k]], each = samples), nrow = samples)
# Sanity check that the previous log_lik is not being overwritten:
if(any(!is.na(log_lik_heldout[heldout==1]))){
warning("Heldout log_lik has been overwritten!!!!")
}
# We save here the log_lik of the fold k in the matrix:
log_lik_heldout[heldout==1] <- log_lik[heldout==1]
}
return(log_lik_heldout)
}
ee
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=2,cores=2,iter=10)
library(caret)
install.packages("caret")
library(caret)
sample(1:100,100,replace=FALSE)
hh <- sample(1:N,size = N,replace = FALSE)
hh
foo <- function(N){
hh <- sample(1:N,size = N,replace = FALSE)
tmp <- rep(0,N)
tmp[hh] <- 1
return(tmp)}
foo(N)
holdout_10 <- matrix(0,nrow=N,ncol=n_fold)
holdout_10
1:10
i:(9+i)
i
i<-1
i
i:(9+i)
seq(1,100,by=10)
hh <- sample(1:N,size = N,replace = FALSE)
holdout_10 <- matrix(0,nrow=N,ncol=n_fold)
for(i in 1:n_fold){
id <- seq(1,100,by=10)
holdout_10[hh[id[i]:(id[i] + 9)],i] <- 1
}
holdout_10
apply(holdout_10,1,sum)
apply(holdout_10,2,sum)
hh <- sample(1:N,size = N,replace = FALSE)
holdout_10 <- matrix(0,nrow=N,ncol=n_fold)
for(i in 1:n_fold){
id <- seq(1,100,by=10)
holdout_10[hh[id[i]:(id[i] + 9)],i] <- 1
}
X <- cbind(rep(1,N),runif(N,-2,2))
y <- matrix(runif(N,-2,2))
data_m <- list(N=N,K=K,X=X,y=y)
data_l <- rep(list(data_m),10)
for(i in 1:10) data_l[[i]]$holdout <- holdout_10[[i]]
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=2,cores=2,iter=10)
ee <- extract_log_lik_K(ss,holdout_10)
split(holdout_10,rep(1:ncol(holdout_10),each=nrow(holdout_10)))
holdout_10 <- split(holdout_10,rep(1:ncol(holdout_10),each=nrow(holdout_10)))
X <- cbind(rep(1,N),runif(N,-2,2))
y <- matrix(runif(N,-2,2))
data_m <- list(N=N,K=K,X=X,y=y)
data_l <- rep(list(data_m),10)
for(i in 1:10) data_l[[i]]$holdout <- holdout_10[[i]]
data_l[[1]]
data_l[[2]]
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=2,cores=2,iter=10)
ee <- extract_log_lik_K(ss,holdout_10)
ee
list_of_stanfits <- ss
K <- length(list_of_stanfits)
list_of_log_liks <- plyr::llply(1:K, function(k){
extract_log_lik(list_of_stanfits[[k]],...)
})
list_of_log_liks <- plyr::llply(1:K, function(k){
extract_log_lik(list_of_stanfits[[k]])
})
list_of_log_liks
str(list_of_log_liks[[1]])
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=4,cores=2)
ss
y <- rnorm(N,c(1,0.5) %*% X,1)
y <- rnorm(N,X %*% c(1, 0.5),1)
y
data_m <- list(N=N,K=K,X=X,y=y)
data_l <- rep(list(data_m),10)
for(i in 1:10) data_l[[i]]$holdout <- holdout_10[[i]]
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=4,cores=2)
ss
ss <- stan_kfold("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=4,cores=2)
ss
stan_kfold
?pbmclapply
?mclapply
stan_kfold <- function(file, list_of_datas, chains, cores,...){
library(pbmcapply)
badRhat <- 1.1 # don't know why we need this?
K <- length(list_of_datas)
model <- stan_model(file=file)
# First parallelize all chains:
sflist <-
pbmclapply(1:(K*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
# Then merge the K * chains to create K stanfits:
stanfit <- list()
for(k in 1:K){
inchains <- (chains*k - 2):(chains*k)
# Merge `chains` of each fold
stanfit[[k]] <- sflist2stanfit(sflist[inchains])
}
return(stanfit)
}
ss <- stan_kfold(file="Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=4,cores=2)
ss[[1]]
model <- stan_model("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan")
list_of_datas <- data_l
sflist <-
pbmclapply(1:(10*4), mc.cores = 2,
function(i){
# Fold number:
k <- round((i+1) / 4)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[1]])
data_l[[1]]
N <- 100
K <- 2
n_fold <- 10
hh <- sample(1:N,size = N,replace = FALSE)
holdout_10 <- matrix(0,nrow=N,ncol=n_fold)
for(i in 1:n_fold){
id <- seq(1,100,by=10)
holdout_10[hh[id[i]:(id[i] + 9)],i] <- 1
}
holdout_10 <- split(holdout_10,rep(1:ncol(holdout_10),each=nrow(holdout_10)))
X <- cbind(rep(1,N),runif(N,-2,2))
y <- rnorm(N,X %*% c(1, 0.5),1)
data_m <- list(N=N,K=K,X=X,y=y)
data_l <- rep(list(data_m),10)
for(i in 1:10) data_l[[i]]$holdout <- holdout_10[[i]]
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[1]])
ss <- stan_kfold(file="Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=4,cores=2)
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[1]])
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[2]])
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[5]])
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[6]])
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[10]])
stan("Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data=data_l[[8]])
model
sflist <-
pbmclapply(1:(K*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
chains <-4
n_fold <- length(list_of_datas)
model <- stan_model(file=file)
model
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
cores<-2
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
sampling(model,list_of_datas[[1]],chains=1,chain_id=1)
data_l
stan_kfold <- function(file, list_of_datas, chains, cores,...){
library(pbmcapply)
badRhat <- 1.1 # don't know why we need this?
n_fold <- length(list_of_datas)
model <- stan_model(file=file)
# First parallelize all chains:
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
# Then merge the K * chains to create K stanfits:
stanfit <- list()
for(k in 1:n_fold){
inchains <- (chains*k - 2):(chains*k)
# Merge `chains` of each fold
stanfit[[k]] <- sflist2stanfit(sflist[inchains])
}
return(stanfit)
}
ss <- stan_kfold(file="Documents/PostDoc_Ghent/STAN_stuff/Models/normal_model_basic_cv.stan",data_l,chains=4,cores=2)
sampling(model, data = data_l[[1]],
chains = 1, chain_id = i)
sampling(model, data = data_l[[2]], chains = 1, chain_id = i)
sampling(model, data = data_l[[3]], chains = 1, chain_id = i)
sampling(model, data = data_l[[10]], chains = 1, chain_id = i)
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
1:(n_fold*chains)
round(((1:(n_fold*chains)) + 1)/chains)
round(2/4)
round(3/4)
((1:(n_fold*chains)) + 1)/chains
?round
ceiling(((1:(n_fold*chains)) + 1)/chains)
floor(((1:(n_fold*chains)) + 1)/chains)
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
k[1] <- 1 #a bug, I guess ...
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
i<-1
k <- round((i+1) / chains)
k
k[1] <- 1 #a bug, I guess ...
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i)
list_of_datas[[1]]
list_of_datas <- data_l
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i)
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
k[1] <- 1 #a bug, I guess ...
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i)
s <- sampling(model, data = list_of_datas[[1]], chains = 1, chain_id = i)
s <- sampling(model, data = list_of_datas[[10]], chains = 1, chain_id = i)
s <- sampling(model, data = list_of_datas[[1]],
chains = 1, chain_id = i)
sflist <-
pbmclapply(1:(n_fold*chains), mc.cores = cores,
function(i){
# Fold number:
k <- round((i+1) / chains)
k[1] <- 1 #a bug, I guess ...
s <- sampling(model, data = list_of_datas[[k]],
chains = 1, chain_id = i,  ...)
return(s)
})
1:(n_fold*chains)
i <- 1:(n_fold*chains)
k <- round((i+1) / chains)
k[1] <- 1 #a bug, I guess ...
k
length(list_of_datas)
table(k)
-150+148
dnorm(1,5,1)
dnorm(5,5,1)
dnorm(5,5,10)
?dnorm
dnorm(5,5,10,log=TRUE)
dnorm(5,5,1,log=TRUE)
?loo
library(loo)
?loo
library(devtools)
install_github(c("duncantl/XMLRPC", "duncantl/RWordPress"))
library(RWordPress)
library(knitr)
opts_knit$set(upload.fun = function(file){uploadFile(file)$url})
options(
WordpressLogin = c(Lionel = "data_gg%68"),
WordpressURL = "https://datascienceplus.com/xmlrpc.php"
)
knit2wp("Desktop/kfold_stan.Rmd",
title = "K-fold cross-validation in Stan",
publish = FALSE)
knit2wp("Desktop/kfold_stan.Rmd",
title = "K-fold cross-validation in Stan",
publish = FALSE)
?knit2wp
knit2wp("Desktop/kfold_stan.Rmd",
title = "K-fold cross-validation in Stan",
publish = FALSE)
ll
knit2wp("Desktop/kfold_stan.Rmd",
title = "K-fold cross-validation in Stan",
publish = FALSE)
packageVersion("gkllTMB")
packageVersion("glmmTMB")
packageVersion("glmmTMB") == "0.2.2.0"
sessionInfo()
library(lme4)
sessionInfo()
library(devtools)
install_github("lionel68/addSE")
install_github("lionel68/addSE")
install_github("lionel68/addSE")
install_github("lionel68/addSE")
install_github("lionel68/addSE")
install_github("lionel68/addSE")
?knitr
library(knitr)
?knitr
citation("ggtern")
citation("tidyverse")
citation('rstan')
citation('corrr')
nr_seedlings <- read.table("data/nr_seedlings.txt", header=T)
head(nr_seedlings)
setwd(".")
setwd(getSrcDirectory()[1])
getSrcDirectory()[1]
getSrcDirectory()
library(rstudioapi)
rstudioapi::getActiveDocumentContext()$path
dirname(rstudioapi::getActiveDocumentContext()$path)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
rm(list=ls())
